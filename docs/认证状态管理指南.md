# 认证状态管理指南

## 概述

pytest-dsl-ui 提供了基于 Playwright storage_state 机制的认证状态管理功能，允许您保存登录状态并在多个测试之间复用，避免重复执行登录操作。

## 设计理念

- **登录逻辑与状态管理分离**：登录逻辑由DSL脚本自定义实现，状态管理提供标准化的保存/加载功能
- **灵活适应不同系统**：支持各种登录方式（用户名密码、验证码、多因子认证等）
- **状态复用**：一次登录，多处使用，提高测试执行效率
- **状态管理**：提供完整的状态生命周期管理（保存、加载、检查、清除）

## 核心关键字

### 1. 检查认证状态
检查指定名称的认证状态是否存在。

```dsl
has_auth = [检查认证状态], 状态名称: "admin_login"
```

**参数：**
- `状态名称`：要检查的认证状态名称

**返回值：**
- `True`：认证状态存在
- `False`：认证状态不存在

### 2. 保存认证状态
保存当前浏览器的认证状态到文件。

```dsl
[保存认证状态], 状态名称: "admin_login", 用户名: "admin", 描述: "管理员登录状态"
```

**参数：**
- `状态名称`：认证状态的唯一标识名称（必填）
- `用户名`：用户名信息，用于元数据记录（可选）
- `描述`：状态描述信息（可选）

### 3. 加载认证状态
加载保存的认证状态，创建新的浏览器上下文。

```dsl
[加载认证状态], 状态名称: "admin_login", 创建新上下文: True
```

**参数：**
- `状态名称`：要加载的认证状态名称（必填）
- `创建新上下文`：是否创建新的浏览器上下文，默认为 true（可选）

### 4. 列出认证状态
列出所有保存的认证状态及其元数据。

```dsl
[列出认证状态], 变量名: "all_states"
```

**参数：**
- `变量名`：保存状态列表的变量名（可选）

### 5. 清除认证状态
清除指定的认证状态文件。

```dsl
[清除认证状态], 状态名称: "admin_login"
```

**参数：**
- `状态名称`：要清除的认证状态名称（必填）

### 6. 清除所有认证状态
清除所有保存的认证状态文件。

```dsl
[清除所有认证状态], 确认清除: True
```

**参数：**
- `确认清除`：必须设置为 True 才能执行清除操作，防止误操作（必填）

## 使用模式

### 模式1：智能登录检查
在测试开始时检查认证状态，如果存在则加载，否则执行登录。

```dsl
# 定义状态名称
$login_state = "admin_session"

# 检查认证状态
has_auth = [检查认证状态], 状态名称: "${login_state}"

if has_auth == False do
    # 执行自定义登录逻辑
    [打开页面], 地址: "https://example.com/login"
    [输入文本], 定位器: "#username", 文本: "admin"
    [输入文本], 定位器: "#password", 文本: "password"
    [点击元素], 定位器: "#login-button"
    [等待元素], 定位器: "#dashboard", 超时时间: 10
    
    # 保存认证状态
    [保存认证状态], 状态名称: "${login_state}", 用户名: "admin"
else
    # 加载认证状态
    [加载认证状态], 状态名称: "${login_state}"
    # 导航到目标页面
    [打开页面], 地址: "https://example.com/dashboard"
end
```

### 模式2：前置登录，后续复用
在测试套件的第一个用例中执行登录并保存状态，后续用例直接加载状态。

**前置登录用例：**
```dsl
@name: "前置-登录并保存状态"

[启动浏览器], 浏览器: "chromium", 无头模式: False

# 执行登录流程
function 执行复杂登录() do
    [打开页面], 地址: "https://example.com/login"
    
    # 处理验证码等复杂登录逻辑
    for i in range(1, 3) do
        captcha = [识别文字验证码], 图片源: "#captcha-image"
        [输入文本], 定位器: "#captcha", 文本: "${captcha}"
        [点击元素], 定位器: "#login"
        
        # 检查登录结果
        success = [检查元素是否可见], 定位器: "#dashboard", 超时时间: 5
        if success == True do
            return True
        end
    end
    [断言], 条件: False, 消息: "登录失败"
end

[执行复杂登录]
[保存认证状态], 状态名称: "main_user_session", 用户名: "testuser"
[关闭浏览器]
```

**业务测试用例：**
```dsl
@name: "业务测试-使用保存的登录状态"

[启动浏览器], 浏览器: "chromium", 无头模式: False
[加载认证状态], 状态名称: "main_user_session"
[打开页面], 地址: "https://example.com/business-page"

# 执行业务测试逻辑...

[关闭浏览器]
```

### 模式3：多用户状态管理
为不同角色的用户保存不同的认证状态。

```dsl
# 为管理员用户保存状态
function 管理员登录() do
    # 管理员登录逻辑...
    [保存认证状态], 状态名称: "admin_session", 用户名: "admin"
end

# 为普通用户保存状态
function 普通用户登录() do
    # 普通用户登录逻辑...
    [保存认证状态], 状态名称: "user_session", 用户名: "normaluser"
end

# 根据测试需要加载不同用户状态
test_role = "admin"  # 或 "user"

if test_role == "admin" do
    [加载认证状态], 状态名称: "admin_session"
else
    [加载认证状态], 状态名称: "user_session"
end
```

## 最佳实践

### 1. 状态命名规范
- 使用描述性的名称：`admin_login_state`、`user_dashboard_auth`
- 包含环境信息：`prod_admin_auth`、`test_user_session`
- 包含用户角色：`manager_auth`、`operator_session`

### 2. 状态生命周期管理
```dsl
# 在测试套件开始前清理旧状态
[清除所有认证状态], 确认清除: True

# 为每个测试环境使用不同的状态名称
$env = "test"  # 或 "prod"、"staging"
$auth_state = "${env}_admin_session"
```

### 3. 错误处理
```dsl
# 检查状态是否存在，处理加载失败的情况
has_auth = [检查认证状态], 状态名称: "user_session"
if has_auth == True do
    try
        [加载认证状态], 状态名称: "user_session"
    catch
        [打印], 内容: "认证状态加载失败，执行重新登录"
        [清除认证状态], 状态名称: "user_session"
        # 执行登录逻辑...
    end
end
```

### 4. 状态维护
```dsl
# 定期清理过期状态（可在CI/CD流水线中执行）
[列出认证状态], 变量名: "states"
[打印], 内容: "当前认证状态: ${states}"

# 清理特定状态
[清除认证状态], 状态名称: "temp_test_session"
```

## 存储位置

认证状态文件默认保存在项目根目录的 `playwright/.auth/` 目录下：
- 文件格式：`{状态名称}.json`
- 自动添加到 `.gitignore`，避免敏感信息泄露
- 包含 cookies、localStorage、sessionStorage 等完整的浏览器状态

## 注意事项

1. **安全性**：认证状态文件包含敏感信息，不应提交到版本控制系统
2. **时效性**：认证状态可能会过期，需要处理加载失败的情况
3. **环境隔离**：不同环境应使用不同的状态名称，避免冲突
4. **清理策略**：定期清理不再需要的认证状态文件
5. **浏览器上下文**：加载认证状态时会创建新的浏览器上下文，注意上下文切换

## 故障排除

### 认证状态加载失败
1. 检查状态文件是否存在
2. 检查状态是否过期
3. 重新执行登录并保存新状态

### 登录状态丢失
1. 检查网站的 session 策略
2. 确认保存状态时的页面状态正确
3. 考虑在关键操作前重新验证登录状态

### 多用户冲突
1. 使用不同的状态名称区分用户
2. 在测试间清理临时状态
3. 使用环境变量管理不同环境的状态 